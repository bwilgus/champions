import pandas as pd
import numpy as np
from teamCon import teamCon
from divisions import teamDiv
import random
import pprint
from idDic import idDic
from APR import aprDic
from definitions import coinToss, conf, conWin, conLoss, div, divChamp, schedule, teamAPR, teamID, tieOvr, tmWin, tmLoss, winPercent
import inspect
import sys

##Links
standingPath = r'C:\users\wilgj\desktop\python crap\standings\\'
dataWB = r'C:\users\wilgj\desktop\python crap\dataOutput.xlsx'

##Test dataframe
tt = ['Kansas Jayhawks','Kansas State Wildcats','TCU Horned Frogs']
tf = pd.DataFrame(data=tt,columns=['Teams'])
##

##Turns off chain dataframe warning
pd.options.mode.chained_assignment = None

##Background Functions
def retrieve_name(var):
    callers_local_vars = inspect.currentframe().f_back.f_locals.items()
    return [var_name for var_name, var_val in callers_local_vars if var_val is var]

def find_index(df, column, find_term):
    df = df[column][df.index[df[column] == find_term]]
    return(df.index[0])
    
def reindexer(df, indexer):
    ri = []
    
    for i in range(len(indexer)):
        ri.append(df.index[df['Teams'] == indexer[i]][0])

    df = df.reindex(ri)

    return(df)
    
def confSort(df):
    df.sort_values('Conf W%',ascending=False,inplace=True)
    df.reset_index(inplace=True,drop=True)

    return(df)

##########Conference Tiebreaker Background Functions###########################################

##This one goes through, determines any ties, and breaks them up via head-to-head.

##If h2h does not break certain ties, it passes back a dataframe with the teams in 
##question marked under the 'Next Step' column

def rr(df, u = 0):
    
    ##Establish Variables
    tieOrder = []
    nextStep = 0
    ns = 0
    nsTeams = []
    nsTeams.append(np.nan)
    nst = []

    ##Turn list or dataframe into appropriate dataframe
    if isinstance(df, list):
        df = pd.DataFrame(df, columns=['Teams'])
    elif isinstance(df, pd.DataFrame):
        df = pd.DataFrame(df['Teams'], columns=['Teams'])    

    ##Establish new dataframe's columns
    df['Wins'] = np.nan
    df['Losses'] = np.nan
    df['Conf W%'] = np.nan
    df['Next Step'] = 0

    df.reset_index(drop=True,inplace=True)

    ties = 0

    ##Does head to head of each 
    for i in range(len(df)):
        wins = 0
        losses = 0
        for x in range(len(df)):
            if i != x:
                teams = [df.Teams[i], df.Teams[x]]
                teams = pd.DataFrame(data=teams,columns=['Teams'])
                game = hth(teams)
                if game.Teams[0] == df.Teams[i]:
                    wins += 1
                elif game.Teams[1] == df.Teams[i]:
                    losses += 1
        
        df.Wins[i] = wins
        df.Losses[i] = losses
        if wins + losses > 0:
            df['Conf W%'][i] = round(wins/(wins+losses)*100.00,2)
        else:
            df['Conf W%'][i] = 0
    df.sort_values('Conf W%',inplace=True, ascending=False)
    lenDF = df['Conf W%'].drop_duplicates()
    lenDF.reset_index(inplace=True,drop=True)
    for i in range(len(lenDF)):
        if len(df[df['Conf W%'] == lenDF[i]]) > 1:
            newDF = df[df['Conf W%'] == lenDF[i]]
            newDF.reset_index(inplace=True,drop=True)
            
            if len(newDF) == newDF['Wins'].sum() and len(newDF) > 2:
                ns += 1
                newDF['Next Step'] = ns
                nsTeams.append(newDF)
                nst = nsTeams
            elif newDF['Wins'].sum() + newDF['Losses'].sum() == 0:
                ns += 1
                newDF['Next Step'] = ns
                nsTeams.append(newDF)
                nst = nsTeams
            else:
                newDF, to, ns, nst = rr(newDF,u+1)
                newDF.reset_index(inplace=True,drop=True)
                
            for x in range(len(newDF)):
                if len(newDF[newDF['Conf W%'] == newDF['Conf W%'][x]]) > 1:
                    ties = 1
                    
            if ties == 0:
                for x in range(len(newDF)):
                    tieOrder.append(newDF['Teams'][x])
            else:
                if ns == 0:
                    newDF, to, ns, nst = rr(newDF,u+1)
                    newDF.reset_index(inplace=True,drop=True)
                    for x in range(len(to)):
                        tieOrder.append(to[x])
                elif ns > 0:
                    for x in range(len(newDF)):
                        tieOrder.append(newDF.Teams[x])
                    
        else:
            tf = df[df['Conf W%'] == lenDF[i]].reset_index(drop=True)
            tieOrder.append(tf['Teams'][0])


    df = reindexer(df, tieOrder)
    df.reset_index(drop=True,inplace=True)
    if u == 0:
        for i in range(len(nst)):
            if i == 0:
                pass
            else:
                for x in range(len(nst[i]['Teams'])):
                    ndx = find_index(df,'Teams',nst[i]['Teams'][x])
                    df['Next Step'][ndx] = i
    
    return(df, tieOrder, nextStep, nst)


##This function takes two teams and grabs the head-to-head record
def hth(df):
    if isinstance(df, list):
        df = pd.DataFrame(df, columns=['Teams'])
    elif isinstance(df, pd.DataFrame):
        df = pd.DataFrame(df['Teams'], columns=['Teams']) 

    try:
        t1ID = idDic[df.Teams[0]]
    except:
        print(df)
    t2ID = idDic[df.Teams[1]]

    if int(t1ID) < int(t2ID):
        gID = t1ID + t2ID
    elif int(t2ID) < int(t1ID):
        gID = t2ID + t1ID
        
    hthG = wsData[wsData['Game ID'] == gID]

    try:
        hthW = list(hthG.Win)[0]
    except:
        hthW = ''
    try:
        hthL = list(hthG.Loss)[0]
    except:
        hthL = ''
        
    df = pd.DataFrame(data=[hthW,hthL],columns=['Teams'])
    return(df)

def inDiv(df):
    ties = df['Next Step'].max()
    ties += 1
    tieNo = 0
    teamOrder = []
    tiedTeams = []
    for i in range(len(df)):
        if df['Next Step'][i] == 0:
            teamOrder.append(df.Teams[i])
        else:
            if tieNo != df['Next Step'][i]:
                tieNo = df['Next Step'][i]
                tdf = df[df['Next Step'] == tieNo]
                tdf = tdf['Teams']
                tdf = pd.DataFrame(data=tdf,columns=['Teams'])
##                tiedTeams.append(tdf)
                ds,t1,t2,t3 = rr(df)
                tdf['Div W%'] = tdf['Teams'].apply(lambda x: ds['Conf W%'][find_index(ds, 'Teams', x)])
                
                                                   
##                for x in range(len(df)):
##                    if df['Next Step'][x] == tieNo:

    

######################Conference Tiebreakers###########################################

def accTies(df):

    origDF = df
    df = confSort(df)
    
    ##Check if divisional tie applies
    dc = df['Div'].drop_duplicates()
    
    if dc[0] == '':
        divBreak = False
    elif len(dc) == 1:
        divBreak = True
    else:
        divBreak = False
    

    
    ##Head-To-Head
    df, throwaway, throwaway2, ns = rr(df)

    ##In-Division Win Percentage
##    if divBreak:
##        if df['Next Step'].sum() > 0:
##            df = inDiv(df)



    return(df)
    





def b10Ties(df):
    origDF = df
    df = confSort(df)

    ##Check if divisional tie applies
    dc = df['Div'].drop_duplicates()
    if len(dc) == 1:
        divBreak = True
    else:
        divBreak = False    

    ##Head-To-Head
    df, throwaway, throwaway2, ns = rr(df)

    ##
    



    return(df)

def b12Ties(df):
    origDF = df
    df = confSort(df)
    
    ##Head-To-Head
    df, throwaway, throwaway2, ns = rr(df)

    ##
    



    return(df)

def p12Ties(df):
    origDF = df
    df = confSort(df)
    
    ##Check if divisional tie applies
    dc = df['Div'].drop_duplicates()
    if len(dc) == 1:
        divBreak = True
    else:
        divBreak = False
    
    ##Head-To-Head
    df, throwaway, throwaway2, ns = rr(df)

    ##
    


    return(df)


def secTies(df):
    origDF = df
    df = confSort(df)
    
    ##Check if divisional tie applies
    dc = df['Div'].drop_duplicates()
    if len(dc) == 1:
        divBreak = True
    else:
        divBreak = False
    
    ##Head-To-Head
    df, throwaway, throwaway2, ns = rr(df)

    ##
    

    return(df)



def aacTies(df):
    origDF = df
    df = confSort(df)
    
    ##Check if divisional tie applies
    dc = df['Div'].drop_duplicates()
    if len(dc) == 1:
        divBreak = True
    else:
        divBreak = False
    
    ##Head-To-Head
    df, throwaway, throwaway2, ns = rr(df)

    ##
    


    return(df)


def cusaTies(df):
    origDF = df
    df = confSort(df)
    
    ##Check if divisional tie applies
    dc = df['Div'].drop_duplicates()
    if len(dc) == 1:
        divBreak = True
    else:
        divBreak = False
    
    ##Head-To-Head
    df, throwaway, throwaway2, ns = rr(df)

    ##
    



    return(df)

def macTies(df):
    origDF = df
    df = confSort(df)
    
    ##Check if divisional tie applies
    dc = df['Div'].drop_duplicates()
    if len(dc) == 1:
        divBreak = True
    else:
        divBreak = False
    
    ##Head-To-Head
    df, throwaway, throwaway2, ns = rr(df)

    ##
    


    return(df)


def mwcTies(df):
    origDF = df
    df = confSort(df)
    
    ##Check if divisional tie applies
    dc = df['Div'].drop_duplicates()
    if len(dc) == 1:
        divBreak = True
    else:
        divBreak = False
    
    ##Head-To-Head
    df, throwaway, throwaway2, ns = rr(df)

    ##
    


    return(df)


def sbcTies(df):
    origDF = df
    df = confSort(df)
    
    ##Check if divisional tie applies
    dc = df['Div'].drop_duplicates()
    if len(dc) == 1:
        divBreak = True
    else:
        divBreak = False
    
    ##Head-To-Head
    df, throwaway, throwaway2, ns = rr(df)

    ##
    


    return(df)

######################################################################################




wsData = pd.read_excel(dataWB, sheet_name='data')
wsData['Game ID'] = wsData['Game ID'].apply('{:0>6}'.format)
WL = pd.read_excel(dataWB, sheet_name='WL')

teams = wsData.Home.drop_duplicates().sort_values()
teams = teams.reset_index(drop=True)
teams = teams.to_frame(name='Teams')

teams['ID'] = teams['Teams'].map(lambda x: teamID(x))
teams['Conference'] = teams['Teams'].map(lambda x: conf(x))
teams['Div'] = teams['Teams'].map(lambda x: div(x))

wkMin = min(wsData.Week)
wkMax = max(wsData.Week)

##userWk = input("Through which week? Min = " + str(wkMin) + ", Max = " + str(wkMax + 1) + ". For pre-season, enter -1. ")
userWk = 16
##print(userWk)

ACC = teams[teams.Conference == 'ACC']
ACC = ACC.reset_index(drop=True)

B10 = teams[teams.Conference == 'Big Ten']
B10 = B10.reset_index(drop=True)

B12 = teams[teams.Conference == 'Big 12']
B12 = B12.reset_index(drop=True)

P12 = teams[teams.Conference == 'Pac-12']
P12 = P12.reset_index(drop=True)

SEC = teams[teams.Conference == 'SEC']
SEC = SEC.reset_index(drop=True)

AAC = teams[teams.Conference == 'American']
AAC = AAC.reset_index(drop=True)

CUSA = teams[teams.Conference == 'C-USA']
CUSA = CUSA.reset_index(drop=True)

MAC = teams[teams.Conference == 'MAC']
MAC = MAC.reset_index(drop=True)

MWC = teams[teams.Conference == 'Mountain West']
MWC = MWC.reset_index(drop=True)

SBC = teams[teams.Conference == 'Sun Belt']
SBC = SBC.reset_index(drop=True)

IND = teams[teams.Conference == 'Independent']
IND = IND.reset_index(drop=True)

cons = [AAC, ACC, B10, B12, CUSA, IND, MAC, MWC, P12, SBC, SEC]

for i in range(len(cons)):
    cons[i]['Wins'] = cons[i]['Teams'].map(lambda x: tmWin(x, userWk))
    cons[i]['Losses'] = cons[i]['Teams'].map(lambda x: tmLoss(x, userWk))
    cons[i]['W%'] = np.vectorize(winPercent)(cons[i]['Wins'], cons[i]['Losses'])


for i in range(len(cons)):
    cons[i]['Conf Wins'] = cons[i]['Teams'].map(lambda x: conWin(x, i, userWk))
    cons[i]['Conf Losses'] = cons[i]['Teams'].map(lambda x: conLoss(x, i, userWk))
    try: cons[i]['Conf W%'] = np.vectorize(winPercent)(cons[i]['Conf Wins'], cons[i]['Conf Losses'])
    except: pass

teams['Wins'] = teams['Teams'].map(lambda x: tmWin(x, userWk))
teams['Losses'] = teams['Teams'].map(lambda x: tmLoss(x, userWk))


ACC = ACC.sort_values(by=['Div','Conf Wins'],ascending=[True,False])
ACC.reset_index(drop=True, inplace=True)

B10 = B10.sort_values(by=['Div','Conf Wins'],ascending=[True,False])
B10.reset_index(drop=True, inplace=True)

B12 = B12.sort_values(by=['Div','Conf Wins'],ascending=[True,False])
B12.reset_index(drop=True, inplace=True)

P12 = P12.sort_values(by=['Div','Conf Wins'],ascending=[True,False])
P12.reset_index(drop=True, inplace=True)

SEC = SEC.sort_values(by=['Div','Conf Wins'],ascending=[True,False])
SEC.reset_index(drop=True, inplace=True)

AAC = AAC.sort_values(by=['Div','Conf Wins'],ascending=[True,False])
AAC.reset_index(drop=True, inplace=True)

CUSA = CUSA.sort_values(by=['Div','Conf Wins'],ascending=[True,False])
CUSA.reset_index(drop=True, inplace=True)

MAC = MAC.sort_values(by=['Div','Conf Wins'],ascending=[True,False])
MAC.reset_index(drop=True, inplace=True)

MWC = MWC.sort_values(by=['Div','Conf Wins'],ascending=[True,False])
MWC.reset_index(drop=True, inplace=True)

SBC = SBC.sort_values(by=['Div','Conf Wins'],ascending=[True,False])
SBC.reset_index(drop=True, inplace=True)

IND = IND.sort_values(by='Wins',ascending=False)
IND.drop(columns=['Conf Wins','Conf Losses'],inplace=True)
IND.reset_index(drop=True, inplace=True)

####Create Division Tables

aacEast = AAC[AAC.Div == 'East']
aacEast = aacEast.reset_index(drop=True)

aacWest = AAC[AAC.Div == 'West']
aacWest = aacWest.reset_index(drop=True)

accAtl = ACC[ACC.Div == 'Atlantic']
accAtl = accAtl.reset_index(drop=True)

accCoast = ACC[ACC.Div == 'Coastal']
accCoast = accCoast.reset_index(drop=True)

b10East = B10[B10.Div == 'East']
b10East = b10East.reset_index(drop=True)

b10West = B10[B10.Div == 'West']
b10West = b10West.reset_index(drop=True)

p12North = P12[P12.Div == 'North']
p12North = p12North.reset_index(drop=True)

p12South = P12[P12.Div == 'South']
p12South = p12South.reset_index(drop=True)

secEast = SEC[SEC.Div == 'East']
secEast = secEast.reset_index(drop=True)

secWest = SEC[SEC.Div == 'West']
secWest = secWest.reset_index(drop=True)

cusaEast = CUSA[CUSA.Div == 'East']
cusaEast = cusaEast.reset_index(drop=True)

cusaWest = CUSA[CUSA.Div == 'West']
cusaWest = cusaWest.reset_index(drop=True)

macEast = MAC[MAC.Div == 'East']
macEast = macEast.reset_index(drop=True)

macWest = MAC[MAC.Div == 'West']
macWest = macWest.reset_index(drop=True)

mwcWest = MWC[MWC.Div == 'West']
mwcWest = mwcWest.reset_index(drop=True)

mwcMtn = MWC[MWC.Div == 'Mountain']
mwcMtn = mwcMtn.reset_index(drop=True)

sbEast = SBC[SBC.Div == 'East']
sbEast = sbEast.reset_index(drop=True)

sbWest = SBC[SBC.Div == 'West']
sbWest = sbWest.reset_index(drop=True)


cons = [AAC, ACC, B10, B12, CUSA, IND, MAC, MWC, P12, SBC, SEC]
divs = [aacEast, aacWest, accAtl, accCoast, b10East, b10West, B12, IND, p12North, p12South, secEast, secWest, cusaEast, cusaWest, macEast, macWest, mwcMtn, mwcWest, sbEast, sbWest]

bowlTeams = teams[teams.Wins >= 6]
bowlTeams.reset_index(drop=True, inplace=True)
bowlTeams57 = teams[teams.Wins == 5]
bowlTeams57.reset_index(drop=True, inplace=True)
bowlTeams57['APR'] = bowlTeams57['Teams'].map(lambda x: teamAPR(x))
bowlTeams57.sort_values(by='APR', ascending=False,inplace=True)
bowlTeams57.reset_index(drop=True, inplace=True)




#Sends HTML versions of the standings into txt files
for i in range(len(divs)):
    dName = retrieve_name(divs[i])
    dName = dName[0]
    docName = dName + '.txt'
    sTxt = open(standingPath + docName, 'w')
    sTxt.write(divs[i].to_html(index=False))
    sTxt.close()
    


aacEast = aacTies(aacEast)
aacWest = aacTies(aacWest)

accAtl = accTies(accAtl)
accCoast = accTies(accCoast)

b10East = b10Ties(b10East)
b10West = b10Ties(b10West)

B12 = b12Ties(B12)

p12North = p12Ties(p12North)
p12South = p12Ties(p12South)

secEast = secTies(secEast)
secWest = secTies(secWest)

cusaEast = cusaTies(cusaEast)
cusaWest = cusaTies(cusaWest)

macEast = macTies(macEast)
macWest = macTies(macWest)

mwcMtn = mwcTies(mwcMtn)
mwcWest = mwcTies(mwcWest)

sbEast = sbcTies(sbEast)
sbWest = sbcTies(sbWest)


##Needs to be after any division DF manipulation
aacEast.name = 'AAC East'
aacWest.name = 'AAC West'
accAtl.name = 'ACC Atlantic'
accCoast.name = 'ACC Coastal'
b10East.name = 'Big 10 East'
b10West.name = 'Big 10 West'
B12.name = 'Big 12'
IND.name = 'Independent'
p12North.name = 'Pac-12 North'
p12South.name = 'Pac-12 South'
secEast.name = 'SEC East'
secWest.name = 'SEC West'
cusaEast.name = 'C-USA East'
cusaWest.name = 'C-USA West'
macEast.name = 'MAC East'
macWest.name = 'MAC West'
mwcMtn.name = 'MWC Mountain'
mwcWest.name = 'MWC West'
sbEast.name = 'Sun Belt East'
sbWest.name = 'Sun Belt West'






#This needs to be after any standings modifications. It saves the conferences as a snapshot.
cons = [AAC, ACC, B10, B12, CUSA, IND, MAC, MWC, P12, SBC, SEC]
divs = [aacEast, aacWest, accAtl, accCoast, b10East, b10West, B12, IND, p12North, p12South, secEast, secWest, cusaEast, cusaWest, macEast, macWest, mwcMtn, mwcWest, sbEast, sbWest]

for i in range(len(divs)):
	print(i)
	if divs[i].name == 'Big 12':
		champs['Big 12 #1'] = divs[i]['Teams'][0]
		champs['Big 12 #2'] = divs[i]['Teams'][1]
	elif divs[i].name == 'Independent':
		pass
	else:
		champs[divs[i].name] = divs[i]['Teams'][0]
